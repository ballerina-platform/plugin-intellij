{
  parserClass="org.intellij.sdk.language.parser.BallerinaParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Ballerina"
  psiImplClassSuffix="Impl"
  psiPackage="org.intellij.sdk.language.psi"
  psiImplPackage="org.intellij.sdk.language.psi.impl"

  elementTypeHolderClass="org.intellij.sdk.language.psi.BallerinaTypes"
  elementTypeClass="org.intellij.sdk.language.psi.BallerinaElementType"
  tokenTypeClass="org.intellij.sdk.language.psi.BallerinaTokenType"

  extends("(simple|sequence|array|tuple|mapping|table|behavioral|singleton|any|never|readonly|distinct|union|intersection|optional|anydata|json|byte|last)_type_descriptor|type_reference")=type_descriptor
  extends("type_cast_expr|checking_expr|trap_expr|query_expr|last_expression|literals|template_expr|structural_constructor_expr|object_constructor_expr|new_expr|regular_expr|variable_reference_expr|field_access_expr|optional_field_access_expr|xml_attribute_access_expr|annot_access_expr|member_access_expr|function_call_expr|method_call_expr|error_constructor_expr|anonymous_function_expr|let_expr|typeof_expr|unary_logical_expr|nil_lifted_expr|range_expr|relational_expr|is_expr|equality_expr|logical_expr|conditional_expr|xml_navigate_expr|transactional_expr|unary_numeric_expr|multiplicative_expr|additive_expr|shift_expr|binary_bitwise_expr|xml_required_attribute_access_expr|xml_optional_attribute_access_expr|multiplicative_expr|bitwise_and_expr|bitwise_xor_expr|bitwise_or_expr|logical_and_expr|logical_or_expr|ternary_conditional_expr|nil_conditional_expr|xml_filter_expr|xml_step_expr|equality_expr|ternary_is_conditional_expr_1|ternary_is_conditional_expr_2")=expression

}

ballerinaFile ::= module_part <<eof>>

type_descriptor ::= simple_type_descriptor
   | sequence_type_descriptor
    | mapping_type_descriptor
   | array_type_descriptor | tuple_type_descriptor
        | table_type_descriptor
   | behavioral_type_descriptor
   | type_reference
        | singleton_type_descriptor
        | any_type_descriptor
        | never_type_descriptor
        | readonly_type_descriptor
        | distinct_type_descriptor
        | union_type_descriptor
        | intersection_type_descriptor
        | anydata_type_descriptor
        | json_type_descriptor
        | byte_type_descriptor
        | last_type_descriptor
        | optional_type_descriptor

last_type_descriptor ::= OPEN_PAREN_TOKEN type_descriptor CLOSE_PAREN_TOKEN {pin=1}

simple_type_descriptor ::=
     tagged_data_type_descriptor
   | nil_type_descriptor
   | boolean_type_descriptor
   | int_type_descriptor
   | floating_point_type_descriptor

int_type_descriptor ::= INT_KEYWORD
floating_point_type_descriptor ::= FLOAT_KEYWORD | DECIMAL_KEYWORD

nil_type_descriptor ::= nil_literal
nil_literal ::=   ( OPEN_PAREN_TOKEN CLOSE_PAREN_TOKEN ) | NULL_KEYWORD

boolean_type_descriptor ::= BOOLEAN_KEYWORD
boolean_literal ::= TRUE_KEYWORD | FALSE_KEYWORD

tagged_data_type_descriptor ::= qualified_identifier

sequence_type_descriptor ::=
   string_type_descriptor
   | xml_type_descriptor

string_type_descriptor ::= STRING_KEYWORD

xml_type_descriptor ::= XML_KEYWORD [type_parameter]
type_parameter ::= LT_TOKEN type_descriptor GT_TOKEN

array_type_descriptor ::= type_descriptor inferable_array_dimension array_dimension*
inferable_array_dimension ::= OPEN_BRACKET_TOKEN [ inferable_array_length ] CLOSE_BRACKET_TOKEN
array_dimension ::= OPEN_BRACKET_TOKEN [ array_length ] CLOSE_BRACKET_TOKEN
inferable_array_length ::= array_length | inferred_array_length
array_length ::= int_literal | constant_reference_expr
inferred_array_length ::= ASTERISK_TOKEN

tuple_type_descriptor ::=
   OPEN_BRACKET_TOKEN tuple_member_type_descriptors CLOSE_BRACKET_TOKEN
tuple_member_type_descriptors ::=
   (tuple_rest_descriptor | member_type_descriptor) (COMMA_TOKEN (tuple_rest_descriptor | member_type_descriptor))* [COMMA_TOKEN tuple_rest_descriptor]
   | [ tuple_rest_descriptor ]
member_type_descriptor ::= [annots] type_descriptor
tuple_rest_descriptor ::= type_descriptor ELLIPSIS_TOKEN

mapping_type_descriptor ::=
   map_type_descriptor | record_type_descriptor

map_type_descriptor ::= MAP_KEYWORD type_parameter

record_type_descriptor ::=
   inclusive_record_type_descriptor | exclusive_record_type_descriptor


inclusive_record_type_descriptor ::=
(RECORD_KEYWORD OPEN_BRACE_TOKEN Tokens CLOSE_BRACE_TOKEN)
   |(RECORD_KEYWORD OPEN_NESTED_BRACE_TOKEN field_descriptor* CLOSE_NESTED_BRACE_TOKEN) {pin=2}
exclusive_record_type_descriptor ::=
   (RECORD_KEYWORD OPEN_BRACE_PIPE_TOKEN TokensPipe CLOSE_BRACE_PIPE_TOKEN)
    | (RECORD_KEYWORD OPEN_NESTED_BRACE_PIPE_TOKEN field_descriptor* [record_rest_descriptor] CLOSE_NESTED_BRACE_PIPE_TOKEN){pin=2}


field_descriptor ::=
   individual_field_descriptor | record_type_inclusion



individual_field_descriptor ::=
   metadata [READONLY_KEYWORD] type_descriptor field_name [QUESTION_MARK_TOKEN | (EQUAL_TOKEN default_expression)] SEMICOLON_TOKEN {pin=3}
field_name ::= identifier
default_expression ::= expression
record_type_inclusion ::= ASTERISK_TOKEN type_reference SEMICOLON_TOKEN {pin=1}
record_rest_descriptor ::= type_descriptor ELLIPSIS_TOKEN SEMICOLON_TOKEN


table_type_descriptor ::= TABLE_KEYWORD row_type_parameter [key_constraint]
row_type_parameter ::= type_parameter
key_constraint ::= key_specifier | key_type_constraint
key_specifier ::= KEY_KEYWORD OPEN_PAREN_TOKEN [ field_name (COMMA_TOKEN field_name)* ] CLOSE_PAREN_TOKEN
key_type_constraint ::= KEY_KEYWORD type_parameter


behavioral_type_descriptor ::=
   error_type_descriptor
   | function_type_descriptor
   | object_type_descriptor
   | future_type_descriptor
   | typedesc_type_descriptor
   | handle_type_descriptor
   | stream_type_descriptor

error_type_descriptor ::= ERROR_KEYWORD [type_parameter]

function_type_descriptor ::=
   function_quals FUNCTION_KEYWORD function_signature
   | [isolated_qual] FUNCTION_KEYWORD
function_quals ::=
   transactional_qual [isolated_qual]
   | [isolated_qual] [transactional_qual]
isolated_qual ::= ISOLATED_KEYWORD
transactional_qual ::= TRANSACTIONAL_KEYWORD
function_signature ::= OPEN_PAREN_TOKEN param_list CLOSE_PAREN_TOKEN return_type_descriptor


param_list ::=
   (required_params [COMMA_TOKEN defaultable_params] [COMMA_TOKEN included_record_params] [COMMA_TOKEN rest_param])
   | (defaultable_params [COMMA_TOKEN included_record_params] [COMMA_TOKEN rest_param])
   | (included_record_params [COMMA_TOKEN rest_param])
   | [rest_param]


required_params ::= (rest_param | defaultable_param | required_param) (COMMA_TOKEN (rest_param | defaultable_param | required_param))*
required_param ::= [annots] type_descriptor [param_name]
defaultable_params ::= defaultable_param (COMMA_TOKEN defaultable_param)*
defaultable_param ::= [annots] type_descriptor [param_name] EQUAL_TOKEN (default_expression | inferred_typedesc_default)
included_record_params ::= included_record_param (COMMA_TOKEN included_record_param)*
included_record_param ::= [annots] ASTERISK_TOKEN type_reference [param_name]
rest_param ::= [annots] type_descriptor ELLIPSIS_TOKEN [param_name]
param_name ::= identifier
inferred_typedesc_default ::= LT_TOKEN GT_TOKEN


return_type_descriptor ::= [ RETURNS_KEYWORD [annots] type_descriptor ]

object_type_descriptor ::=
object_type_quals OBJECT_KEYWORD (IGNORED_OPEN_BRACE_TOKEN|OPEN_NESTED_BRACE_TOKEN | OPEN_BRACE_TOKEN)
      object_member_descriptor*
   (IGNORED_CLOSE_BRACE_TOKEN|CLOSE_NESTED_BRACE_TOKEN | CLOSE_BRACE_TOKEN)
object_type_quals ::=
   isolated_qual [object_network_qual]
   | [object_network_qual [isolated_qual]]
object_member_descriptor ::=
   object_field_descriptor
   | method_decl
   | remote_method_decl
   | resource_method_decl
   | object_type_inclusion

object_network_qual ::= CLIENT_KEYWORD | SERVICE_KEYWORD
object_field_descriptor ::=
   metadata [PUBLIC_KEYWORD] type_descriptor field_name SEMICOLON_TOKEN

method_decl ::=
   metadata [PUBLIC_KEYWORD] method_quals
   FUNCTION_KEYWORD method_name function_signature SEMICOLON_TOKEN
method_quals ::= function_quals
private method_name ::= identifier | special_method_name
special_method_name ::= MAP_KEYWORD | JOIN_KEYWORD | START_KEYWORD

remote_method_decl ::=
   metadata remote_method_quals
   FUNCTION_KEYWORD remote_method_name function_signature SEMICOLON_TOKEN
remote_method_quals ::=
   remote_qual function_quals
   | isolated_qual [transactional_qual] remote_qual
   | transactional_qual [isolated_qual] remote_qual
   | isolated_qual remote_qual transactional_qual
   | transactional_qual remote_qual isolated_qual
remote_qual ::= REMOTE_KEYWORD
private remote_method_name ::= identifier // check

resource_method_decl ::=
   metadata resource_method_quals
   FUNCTION_KEYWORD resource_method_name resource_path function_signature SEMICOLON_TOKEN
resource_method_quals ::=
   resource_qual function_quals
   | isolated_qual [transactional_qual] resource_qual
   | transactional_qual [isolated_qual] resource_qual
   | isolated_qual resource_qual transactional_qual
   | transactional_qual resource_qual isolated_qual
resource_qual ::= RESOURCE_KEYWORD
resource_method_name ::= identifier // check
resource_path ::=
   dot_resource_path
   | resource_path_segment (SLASH_TOKEN resource_path_segment)* [SLASH_TOKEN resource_path_rest_param]
   | resource_path_rest_param
dot_resource_path ::= DOT_TOKEN
resource_path_segment ::= resource_path_segment_name | resource_path_segment_param
resource_path_segment_name ::= identifier
resource_path_segment_param ::= OPEN_BRACKET_TOKEN[annots] type_descriptor [param_name] CLOSE_BRACKET_TOKEN
resource_path_rest_param ::= OPEN_BRACKET_TOKEN [annots] type_descriptor ELLIPSIS_TOKEN [param_name] CLOSE_BRACKET_TOKEN

object_type_inclusion ::= ASTERISK_TOKEN type_reference SEMICOLON_TOKEN

future_type_descriptor ::= FUTURE_KEYWORD [type_parameter]

typedesc_type_descriptor ::= TYPEDESC_KEYWORD [type_parameter]

handle_type_descriptor ::= HANDLE_KEYWORD

stream_type_descriptor ::= STREAM_KEYWORD [stream_type_parameters]
stream_type_parameters ::= LT_TOKEN type_descriptor [COMMA_TOKEN type_descriptor] GT_TOKEN

type_reference ::= qualified_identifier | identifier

singleton_type_descriptor ::= simple_const_expr

any_type_descriptor ::= ANY_KEYWORD

never_type_descriptor ::= NEVER_KEYWORD

readonly_type_descriptor ::= READONLY_KEYWORD

distinct_type_descriptor ::= DISTINCT_KEYWORD type_descriptor

union_type_descriptor ::= type_descriptor PIPE_TOKEN type_descriptor

intersection_type_descriptor ::= type_descriptor BITWISE_AND_TOKEN type_descriptor

optional_type_descriptor ::= type_descriptor QUESTION_MARK_TOKEN

anydata_type_descriptor ::= ANYDATA_KEYWORD


json_type_descriptor ::= JSON_KEYWORD


byte_type_descriptor ::= BYTE_KEYWORD


binding_pattern ::=
   capture_binding_pattern
   | wildcard_binding_pattern
   | list_binding_pattern
   | mapping_binding_pattern
   | error_binding_pattern
capture_binding_pattern ::= variable_name
variable_name ::= identifier
wildcard_binding_pattern ::= UNDERSCORE_KEYWORD
list_binding_pattern ::= OPEN_BRACKET_TOKEN list_member_binding_patterns CLOSE_BRACKET_TOKEN
list_member_binding_patterns ::=
   binding_pattern (COMMA_TOKEN binding_pattern)* [COMMA_TOKEN rest_binding_pattern]
   | [ rest_binding_pattern ]
mapping_binding_pattern ::= (OPEN_NESTED_BRACE_TOKEN|OPEN_BRACE_TOKEN) field_binding_patterns (CLOSE_NESTED_BRACE_TOKEN|CLOSE_BRACE_TOKEN)
field_binding_patterns ::=
   field_binding_pattern (COMMA_TOKEN field_binding_pattern)* [COMMA_TOKEN rest_binding_pattern]
   | [ rest_binding_pattern ]
field_binding_pattern ::=
   field_name COLON_TOKEN binding_pattern
   | variable_name
rest_binding_pattern ::= ELLIPSIS_TOKEN variable_name
error_binding_pattern ::= ERROR_KEYWORD [error_type_reference] OPEN_PAREN_TOKEN error_arg_list_binding_pattern CLOSE_PAREN_TOKEN
error_type_reference ::= type_reference
error_arg_list_binding_pattern ::=
   error_message_binding_pattern [COMMA_TOKEN error_cause_binding_pattern] [COMMA_TOKEN error_field_binding_patterns]
   | [error_field_binding_patterns]
error_message_binding_pattern ::= simple_binding_pattern
error_cause_binding_pattern ::= simple_binding_pattern | error_binding_pattern
simple_binding_pattern ::= capture_binding_pattern | wildcard_binding_pattern
error_field_binding_patterns ::=
   named_arg_binding_pattern (COMMA_TOKEN named_arg_binding_pattern)* [COMMA_TOKEN rest_binding_pattern]
   | rest_binding_pattern
named_arg_binding_pattern ::= arg_name EQUAL_TOKEN binding_pattern


typed_binding_pattern ::= inferable_type_descriptor binding_pattern
inferable_type_descriptor ::= type_descriptor | VAR_KEYWORD

private qualified_identifier ::= module_prefix NoSpaceColon identifier
private module_prefix ::= predeclared_prefix | identifier

private NoSpaceColon ::= COLON_TOKEN

expression ::=
   anonymous_function_expr | literals | new_expr | method_call_expr | field_access_expr | function_call_expr | variable_reference_expr
         | template_expr
         | structural_constructor_expr
         | object_constructor_expr
         | optional_field_access_expr
         | xml_attribute_access_expr
         | annot_access_expr
         | member_access_expr
         | error_constructor_expr
         | let_expr
         | typeof_expr
         | unary_logical_expr
         | nil_lifted_expr
         | range_expr
         | is_expr
         | conditional_expr
         | relational_expr
         | equality_expr
         | logical_expr
         | xml_navigate_expr
         | transactional_expr
   | type_cast_expr
   | checking_expr
   | trap_expr
   | query_expr
   | last_expression


last_expression ::= OPEN_PAREN_TOKEN expression CLOSE_PAREN_TOKEN

// original
private nil_lifted_expr ::=
  unary_numeric_expr
  | multiplicative_expr
  | additive_expr
  | shift_expr
  | binary_bitwise_expr


const_expr ::=
   literal
   | template_expr
   | structural_constructor_expr
   | constant_reference_expr
   | type_cast_expr
   | unary_logical_expr
   | nil_lifted_expr
   | range_expr
   | relational_expr
   | is_expr
   | conditional_expr
   | equality_expr
   | logical_expr
   | last_const_expr

last_const_expr ::= OPEN_PAREN_TOKEN const_expr CLOSE_PAREN_TOKEN

constant_reference_expr ::= variable_reference_expr

simple_const_expr ::=
  nil_literal
  | boolean_literal
  | [Sign] int_literal
  | [Sign] floating_point_literal
  | string_literal
  | constant_reference_expr

Sign ::= PLUS_TOKEN | MINUS_TOKEN

literals ::= string_literal | nil_literal | boolean_literal | numeric_literal | byte_array_literal

byte_array_literal ::= (BASE16_KEYWORD string_template_expr) | (BASE64_KEYWORD string_template_expr)


numeric_literal ::= int_literal | floating_point_literal

template_expr ::=
   string_template_expr


string_template_expr ::= [IDENTIFIER_TOKEN] STRING_TEMPLATE_START_TOKEN template_content* STRING_TEMPLATE_END_TOKEN {pin=2}
template_content ::= TEMPLATE_STRING | interpolation {recoverWhile=recoverTemplate}
private recoverTemplate ::= !(STRING_TEMPLATE_END_TOKEN|INTERPOLATION_START_TOKEN|TEMPLATE_STRING)
interpolation ::= INTERPOLATION_START_TOKEN expression INTERPOLATION_END_TOKEN {pin=1}


structural_constructor_expr ::= list_constructor_expr | table_constructor_expr | mapping_constructor_expr

list_constructor_expr ::= OPEN_BRACKET_TOKEN [ list_member_list ] CLOSE_BRACKET_TOKEN
list_member_list ::= list_member (COMMA_TOKEN list_member)*
list_member ::= single_list_member | spread_list_member
single_list_member ::= expression
spread_list_member ::= spread | aggregated_variable_reference
spread ::= ELLIPSIS_TOKEN expression

mapping_constructor_expr ::= (IGNORED_OPEN_BRACE_TOKEN | OPEN_NESTED_BRACE_TOKEN | OPEN_BRACE_TOKEN) [field (COMMA_TOKEN field)*] (IGNORED_CLOSE_BRACE_TOKEN | CLOSE_NESTED_BRACE_TOKEN | CLOSE_BRACE_TOKEN)
field ::=
  specific_field
  | computed_name_field
  | spread_field
specific_field ::=
   [READONLY_KEYWORD] (field_name | string_literal) COLON_TOKEN value_expr
   | [READONLY_KEYWORD] variable_name
value_expr ::= expression
computed_name_field ::= OPEN_BRACKET_TOKEN field_name_expr CLOSE_BRACKET_TOKEN COLON_TOKEN value_expr
field_name_expr ::= expression
spread_field ::= spread

table_constructor_expr ::= TABLE_KEYWORD [key_specifier] OPEN_BRACKET_TOKEN [row_list] CLOSE_BRACKET_TOKEN
row_list ::= mapping_constructor_expr (COMMA_TOKEN mapping_constructor_expr)*

object_constructor_expr ::=
   [annots] object_type_quals OBJECT_KEYWORD [type_reference] object_constructor_block
object_constructor_block ::= OPEN_NESTED_BRACE_TOKEN object_member* CLOSE_NESTED_BRACE_TOKEN
object_member ::= object_field | method_defn | remote_method_defn | resource_method_defn

object_visibility_qual ::= PUBLIC_KEYWORD|PRIVATE_KEYWORD

object_field ::=
   metadata [object_visibility_qual] [FINAL_KEYWORD]
   type_descriptor field_name [EQUAL_TOKEN field_initializer] SEMICOLON_TOKEN
field_initializer ::= expression

method_defn ::=
   metadata [object_visibility_qual] method_quals
   FUNCTION_KEYWORD method_name function_signature method_defn_body

method_defn_body ::= function_defn_body

remote_method_defn ::=
   metadata remote_method_quals
   FUNCTION_KEYWORD remote_method_name function_signature method_defn_body

resource_method_defn ::=
   metadata resource_method_quals
   FUNCTION_KEYWORD resource_method_name resource_path function_signature method_defn_body {pin=3}

new_expr ::= explicit_new_expr | implicit_new_expr
explicit_new_expr ::= NEW_KEYWORD class_descriptor OPEN_PAREN_TOKEN arg_list CLOSE_PAREN_TOKEN
class_descriptor ::= qualified_identifier | identifier | stream_type_descriptor


implicit_new_expr ::= NEW_KEYWORD [OPEN_PAREN_TOKEN arg_list CLOSE_PAREN_TOKEN]


variable_reference_expr ::= variable_reference
variable_reference ::= qualified_identifier | identifier | xml_qualified_name
xml_qualified_name ::= xml_namespace_prefix NoSpaceColon identifier

field_access_expr ::= expression DOT_TOKEN field_name


optional_field_access_expr ::= expression OPTIONAL_CHAINING_TOKEN field_name

// original
private xml_attribute_access_expr ::= xml_required_attribute_access_expr | xml_optional_attribute_access_expr
xml_required_attribute_access_expr ::= expression DOT_TOKEN xml_attribute_name
xml_optional_attribute_access_expr ::= expression OPTIONAL_CHAINING_TOKEN xml_attribute_name {extends = expression}
xml_attribute_name ::= xml_qualified_name | qualified_identifier | identifier

annot_access_expr ::= expression ANNOT_CHAINING_TOKEN annot_tag_reference

member_access_expr ::= expression OPEN_BRACKET_TOKEN (multi_key_expression | key_expression) CLOSE_BRACKET_TOKEN
//container_expression ::= expression
key_expression ::= expression
multi_key_expression ::= expression (COMMA_TOKEN expression)+

function_call_expr ::= function_reference OPEN_PAREN_TOKEN arg_list CLOSE_PAREN_TOKEN
function_reference ::= variable_reference
arg_list ::= positional_args [COMMA_TOKEN other_args] | [other_args]
other_args ::= named_args | rest_arg | type

// wrong order
positional_args ::= (named_arg | positional_arg) (COMMA_TOKEN (named_arg | positional_arg))*
positional_arg ::= expression | type

named_args ::= named_arg (COMMA_TOKEN named_arg)*
named_arg ::= arg_name EQUAL_TOKEN expression
arg_name ::= identifier

rest_arg ::= spread | aggregated_variable_reference

method_call_expr ::= expression DOT_TOKEN method_name OPEN_PAREN_TOKEN arg_list? CLOSE_PAREN_TOKEN

// wrong order
error_constructor_expr ::= ERROR_KEYWORD [error_type_reference] OPEN_PAREN_TOKEN error_arg_list CLOSE_PAREN_TOKEN
error_arg_list ::= (named_arg | positional_arg) [COMMA_TOKEN (named_arg | positional_arg)] (COMMA_TOKEN named_arg)*

anonymous_function_expr ::= explicit_anonymous_function_expr | infer_anonymous_function_expr
explicit_anonymous_function_expr ::= FUNCTION_KEYWORD function_signature ( function_defn_body | expr_function_body )


infer_anonymous_function_expr ::= infer_param_list expr_function_body
infer_param_list ::= identifier | OPEN_PAREN_TOKEN[identifier (COMMA_TOKEN identifier)*]CLOSE_PAREN_TOKEN


let_expr ::= LET_KEYWORD let_var_decl (COMMA_TOKEN let_var_decl)* IN_KEYWORD expression

let_var_decl ::= [annots] typed_binding_pattern EQUAL_TOKEN expression

type_cast_expr ::= LT_TOKEN type_cast_param GT_TOKEN expression
type_cast_param ::= [annots] type_descriptor | annots

typeof_expr ::= TYPEOF_KEYWORD expression

unary_numeric_expr ::=
   PLUS_TOKEN expression
   | MINUS_TOKEN expression
   | NEGATION_TOKEN expression

unary_logical_expr ::= EXCLAMATION_MARK_TOKEN expression

multiplicative_expr ::=
   expression (ASTERISK_TOKEN | SLASH_TOKEN | PERCENT_TOKEN) expression

additive_expr ::=
   expression (PLUS_TOKEN | MINUS_TOKEN) expression


//shift_expr ::=
//   expression (DOUBLE_LT_TOKEN|DOUBLE_GT_TOKEN|TRIPPLE_GT_TOKEN) expression

shift_expr ::=
   expression (DOUBLE_LT_TOKEN|(GT_TOKEN)+) expression

range_expr ::=
   expression (ELLIPSIS_TOKEN|DOUBLE_DOT_LT_TOKEN) expression

//relational_expr ::=
//   expression (LT_TOKEN|GT_TOKEN|LT_EQUAL_TOKEN|GT_EQUAL_TOKEN) expression

relational_expr ::=
   expression ( LT_TOKEN|GT_TOKEN|LT_EQUAL_TOKEN|GT_EQUAL_TOKEN) expression

is_expr ::=
   expression ((EXCLAMATION_MARK_TOKEN IS_KEYWORD) | IS_KEYWORD) type_descriptor


equality_expr ::=
   expression (DOUBLE_EQUAL_TOKEN|NOT_EQUAL_TOKEN|TRIPPLE_EQUAL_TOKEN|NOT_DOUBLE_EQUAL_TOKEN) expression

// original
private binary_bitwise_expr ::=
   bitwise_and_expr
   | bitwise_xor_expr
   | bitwise_or_expr
bitwise_and_expr ::= expression BITWISE_AND_TOKEN expression
bitwise_xor_expr ::= expression BITWISE_XOR_TOKEN expression
bitwise_or_expr ::= expression PIPE_TOKEN expression

// original
private logical_expr ::= logical_and_expr | logical_or_expr
logical_and_expr ::= expression LOGICAL_AND_TOKEN expression
logical_or_expr ::= expression LOGICAL_OR_TOKEN expression

ternary_type_descriptor ::= simple_type_descriptor
                               | sequence_type_descriptor
                                | mapping_type_descriptor
                               | array_type_descriptor | tuple_type_descriptor
                                    | table_type_descriptor
                               | behavioral_type_descriptor
                               | type_reference
                                    | singleton_type_descriptor
                                    | any_type_descriptor
                                    | never_type_descriptor
                                    | readonly_type_descriptor
                                    | distinct_type_descriptor
                                    | union_type_descriptor
                                    | intersection_type_descriptor
                                    | anydata_type_descriptor
                                    | json_type_descriptor
                                    | byte_type_descriptor
                                    | last_type_descriptor

// Todo : Confusion with is expression inside ternary expression. Fix it.
private conditional_expr ::=
  ternary_is_conditional_expr_1
  | ternary_is_conditional_expr_2
  | ternary_conditional_expr
  | nil_conditional_expr
ternary_is_conditional_expr_1 ::= expression ((EXCLAMATION_MARK_TOKEN IS_KEYWORD) | IS_KEYWORD) ternary_type_descriptor QUESTION_MARK_TOKEN* expression
ternary_is_conditional_expr_2 ::= expression ((EXCLAMATION_MARK_TOKEN IS_KEYWORD) | IS_KEYWORD) ternary_type_descriptor QUESTION_MARK_TOKEN* expression COLON_TOKEN expression
ternary_conditional_expr ::= expression QUESTION_MARK_TOKEN expression [COLON_TOKEN expression]
nil_conditional_expr ::= expression ELVIS_TOKEN expression

checking_expr ::= checking_keyword expression
checking_keyword ::= CHECK_KEYWORD | CHECKPANIC_KEYWORD

trap_expr ::= TRAP_KEYWORD expression

query_expr ::= query_select_expr | query_collect_expr
query_select_expr ::= [query_construct_type] query_pipeline select_clause [on_conflict_clause]
query_collect_expr ::= query_pipeline collect_clause
query_pipeline ::= from_clause intermediate_clause*
intermediate_clause ::=
   from_clause
   | where_clause
   | let_clause
   | join_clause
   | limit_clause
   | order_by_clause
   | group_by_clause

from_clause ::= FROM_KEYWORD typed_binding_pattern IN_KEYWORD expression

where_clause ::= WHERE_KEYWORD expression

let_clause ::= LET_KEYWORD let_var_decl (COMMA_TOKEN let_var_decl)*

join_clause ::= [OUTER_KEYWORD] JOIN_KEYWORD typed_binding_pattern IN_KEYWORD expression join_on_condition
join_on_condition ::= ON_KEYWORD expression EQUALS_KEYWORD expression

limit_clause ::= LIMIT_KEYWORD expression

order_by_clause ::= ORDER_KEYWORD BY_KEYWORD order_key (COMMA_TOKEN order_key)*
order_key ::= expression [order_direction]
order_direction ::= ASCENDING_KEYWORD | DESCENDING_KEYWORD

aggregated_variable_reference ::= identifier

group_by_clause ::= GROUP_KEYWORD BY_KEYWORD grouping_key (COMMA_TOKEN grouping_key)*
grouping_key ::=
   variable_name
   | inferable_type_descriptor variable_name EQUAL_TOKEN expression

collect_clause ::= COLLECT_KEYWORD expression

select_clause ::= SELECT_KEYWORD expression

query_construct_type ::=
  MAP_KEYWORD
  | TABLE_KEYWORD key_specifier
  | STREAM_KEYWORD

on_conflict_clause ::= ON_KEYWORD CONFLICT_KEYWORD expression

// original
private xml_navigate_expr ::= xml_filter_expr | xml_step_expr

xml_name_pattern ::= xml_atomic_name_pattern (PIPE_TOKEN xml_atomic_name_pattern)*

xml_atomic_name_pattern ::=
  ASTERISK_TOKEN
  | xml_namespace_prefix NoSpaceColon identifier
  | xml_namespace_prefix NoSpaceColon ASTERISK_TOKEN
  | identifier

xml_filter_expr ::= expression DOT_LT_TOKEN xml_name_pattern GT_TOKEN

xml_step_expr ::= expression xml_step_start xml_step_extend*

xml_step_start ::=
   xml_all_children_step
   | xml_element_children_step
   | xml_element_descendants_step
xml_all_children_step ::= SLASH_ASTERISK_TOKEN
xml_element_children_step ::= SLASH_LT_TOKEN xml_name_pattern GT_TOKEN
xml_element_descendants_step ::= DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN xml_name_pattern GT_TOKEN

xml_step_extend ::=
   DOT_LT_TOKEN xml_name_pattern GT_TOKEN
   | OPEN_BRACKET_TOKEN expression CLOSE_BRACKET_TOKEN
   | DOT_TOKEN method_name OPEN_PAREN_TOKEN arg_list CLOSE_PAREN_TOKEN

transactional_expr ::= TRANSACTIONAL_KEYWORD

expr_function_body ::= RIGHT_DOUBLE_ARROW_TOKEN expression

external_function_body ::= EQUAL_TOKEN [annots] EXTERNAL_KEYWORD

xmlns_decl ::= XMLNS_KEYWORD xml_namespace_uri [ AS_KEYWORD xml_namespace_prefix ] SEMICOLON_TOKEN
xml_namespace_uri ::= simple_const_expr
xml_namespace_prefix ::= identifier

module_part ::= import_decl* moduleDefinitions* {pin=2}
moduleDefinitions ::= other_decl {elementType=other_decl}
other_decl ::=
   listener_decl
   | module_class_defn
   | service_decl
   | function_defn
   | module_const_decl
   | module_type_defn
   | module_var_decl
   | module_enum_decl
   | module_xmlns_decl
   | annotation_decl {recoverWhile=recoverModuleDecl}

private recoverModuleDecl ::= !(LISTENER_KEYWORD
|SERVICE_KEYWORD|TYPE_KEYWORD|PUBLIC_KEYWORD|PRIVATE_KEYWORD
|FUNCTION_KEYWORD|CONST_KEYWORD|CLASS_KEYWORD|ENUM_KEYWORD|XMLNS_KEYWORD
|ANNOTATION_KEYWORD|IMPORT_KEYWORD|ISOLATED_KEYWORD|TRANSACTIONAL_KEYWORD
|DISTINCT_KEYWORD|READONLY_KEYWORD|CLIENT_KEYWORD|FINAL_KEYWORD|CONFIGURABLE_KEYWORD
|BOOLEAN_KEYWORD|DECIMAL_KEYWORD|ERROR_KEYWORD|FLOAT_KEYWORD|FUTURE_KEYWORD|INT_KEYWORD|MAP_KEYWORD
|OBJECT_KEYWORD|STREAM_KEYWORD|STRING_KEYWORD|TABLE_KEYWORD|TRANSACTION_KEYWORD|TYPEDESC_KEYWORD
|XML_KEYWORD|NULL_KEYWORD|OPEN_PAREN_TOKEN|REMOTE_KEYWORD|ABSTRACT_KEYWORD|RECORD_KEYWORD|AS_KEYWORD|ON_KEYWORD|RESOURCE_KEYWORD|SOURCE_KEYWORD
|WORKER_KEYWORD|PARAMETER_KEYWORD|FIELD_KEYWORD|EXTERNAL_KEYWORD|TYPEOF_KEYWORD|LOCK_KEYWORD
|FORK_KEYWORD|TRAP_KEYWORD|KEY_KEYWORD|LET_KEYWORD|NEW_KEYWORD|FROM_KEYWORD
|WHERE_KEYWORD|SELECT_KEYWORD|START_KEYWORD|FLUSH_KEYWORD|WAIT_KEYWORD|COMMIT_KEYWORD
|ROLLBACK_KEYWORD|RETRY_KEYWORD|BASE16_KEYWORD|BASE64_KEYWORD|MATCH_KEYWORD|CONFLICT_KEYWORD
|LIMIT_KEYWORD|JOIN_KEYWORD|OUTER_KEYWORD|ORDER_KEYWORD|BY_KEYWORD|ASCENDING_KEYWORD
|DESCENDING_KEYWORD|UNDERSCORE_KEYWORD|AT_TOKEN|MARKDOWN_DOCUMENTATION_LINE_START
|BYTE_KEYWORD|JSON_KEYWORD|HANDLE_KEYWORD|ANY_KEYWORD|ANYDATA_KEYWORD|SEMICOLON_TOKEN
|NEVER_KEYWORD|VAR_KEYWORD|FAIL_KEYWORD|IDENTIFIER_TOKEN)



import_decl ::= IMPORT_KEYWORD [org_name SLASH_TOKEN] module_name [AS_KEYWORD import_prefix] SEMICOLON_TOKEN {pin=1}
import_prefix ::= module_prefix | UNDERSCORE_KEYWORD
org_name ::= import_identifier
module_name ::= import_identifier (DOT_TOKEN import_identifier)* {pin=1}
import_identifier ::= identifier

predeclared_prefix ::=
   BOOLEAN_KEYWORD
   | DECIMAL_KEYWORD
   | ERROR_KEYWORD
   | FLOAT_KEYWORD
   | FUNCTION_KEYWORD
   | FUTURE_KEYWORD
   | INT_KEYWORD
   | MAP_KEYWORD
   | OBJECT_KEYWORD
   | STREAM_KEYWORD
   | STRING_KEYWORD
   | TABLE_KEYWORD
   | TRANSACTION_KEYWORD
   | TYPEDESC_KEYWORD
   | XML_KEYWORD

listener_decl ::=
   (metadata
   [PUBLIC_KEYWORD] LISTENER_KEYWORD listener_variable_name EQUAL_TOKEN expression SEMICOLON_TOKEN)
  | (metadata
   [PUBLIC_KEYWORD] LISTENER_KEYWORD type_descriptor listener_variable_name EQUAL_TOKEN expression SEMICOLON_TOKEN) {pin=3}

listener_variable_name ::= IDENTIFIER_TOKEN

service_decl ::=
   metadata [isolated_qual]
   SERVICE_KEYWORD [type_descriptor] [attach_point] ON_KEYWORD expression_list OPEN_BRACE_TOKEN service_members CLOSE_BRACE_TOKEN [SEMICOLON_TOKEN] {pin=3}

service_members ::= service_member* {recoverWhile=recoverService}

service_member ::=
   object_field
   | method_defn
   | remote_method_defn
   | resource_method_defn

private recoverService ::= !(CLOSE_BRACE_TOKEN)

attach_point ::= absolute_resource_path | string_literal
absolute_resource_path ::= (SLASH_TOKEN resource_path_segment_name)+ | root_resource_path
root_resource_path ::= SLASH_TOKEN

expression_list ::= expression (COMMA_TOKEN expression)*

function_defn ::=
(metadata [PUBLIC_KEYWORD] [FINAL_KEYWORD] function_type_descriptor IDENTIFIER_TOKEN SEMICOLON_TOKEN)
 |  (metadata
   [PUBLIC_KEYWORD] function_quals
   FUNCTION_KEYWORD [identifier] function_signature function_defn_body) {pin=4}


function_defn_body ::=
    ((OPEN_NESTED_BRACE_TOKEN) TokensIgnore (CLOSE_NESTED_BRACE_TOKEN) [SEMICOLON_TOKEN])
   | ((OPEN_BRACE_TOKEN) Tokens (CLOSE_BRACE_TOKEN) [SEMICOLON_TOKEN])
   | expr_function_body SEMICOLON_TOKEN
   | external_function_body SEMICOLON_TOKEN

module_type_defn ::=
   metadata
   [PUBLIC_KEYWORD] TYPE_KEYWORD identifier type_descriptor SEMICOLON_TOKEN {pin=3}

module_class_defn ::=
   metadata
   [PUBLIC_KEYWORD] class_type_quals CLASS_KEYWORD identifier OPEN_BRACE_TOKEN
      class_members
  CLOSE_BRACE_TOKEN [SEMICOLON_TOKEN] {pin=4}

class_members ::= class_member* {recoverWhile=recoverClass}
class_member ::=
   object_field
   | method_defn
   | remote_method_defn
   | resource_method_defn
   | object_type_inclusion

Tokens ::= allTokens* {recoverWhile=recoverClass}
TokensPipe ::= allTokensPipe* {recoverWhile=recoverPipe}
TokensIgnore ::= allTokensIgnore* {recoverWhile=recoverIgnore}

private recoverPipe ::= !(CLOSE_BRACE_PIPE_TOKEN)
private recoverClass ::= !(CLOSE_BRACE_TOKEN)
private recoverIgnore ::= !(CLOSE_NESTED_BRACE_TOKEN)

class_type_quals ::= (DISTINCT_KEYWORD | READONLY_KEYWORD | isolated_qual | object_network_qual)*

module_var_decl ::= module_init_var_decl | module_no_init_var_decl

module_init_var_decl ::= metadata [PUBLIC_KEYWORD] [module_init_var_quals] typed_binding_pattern EQUAL_TOKEN module_var_init SEMICOLON_TOKEN {pin=5}
module_init_var_quals ::= (FINAL_KEYWORD | isolated_qual)+ | CONFIGURABLE_KEYWORD
module_var_init ::= expression | QUESTION_MARK_TOKEN

module_no_init_var_decl ::= metadata [PUBLIC_KEYWORD] [FINAL_KEYWORD] type_descriptor variable_name SEMICOLON_TOKEN {pin=5}

module_const_decl ::= metadata PUBLIC_KEYWORD? CONST_KEYWORD (type_descriptor identifier | identifier) EQUAL_TOKEN const_expr SEMICOLON_TOKEN {pin=5}

module_enum_decl ::=
   metadata
   [PUBLIC_KEYWORD] ENUM_KEYWORD identifier OPEN_BRACE_TOKEN Tokens CLOSE_BRACE_TOKEN [SEMICOLON_TOKEN] {pin=3}


module_xmlns_decl ::= xmlns_decl


metadata ::= [documentationString][annots]

annots ::= annotation+
annotation ::= AT_TOKEN annot_tag_reference annot_value

annotation_decl ::=
   (metadata
   [PUBLIC_KEYWORD] [CONST_KEYWORD] ANNOTATION_KEYWORD annot_tag
   [ON_KEYWORD annot_attach_points] SEMICOLON_TOKEN)
    | metadata
         [PUBLIC_KEYWORD] [CONST_KEYWORD] ANNOTATION_KEYWORD [type_descriptor] annot_tag
         [ON_KEYWORD annot_attach_points] SEMICOLON_TOKEN{pin=4}
annot_tag ::= identifier

private annot_tag_reference ::= qualified_identifier | identifier
annot_value ::= [annot_body_open | annot_body_nested | mapping_constructor_expr]

annot_body_open ::= OPEN_BRACE_TOKEN Tokens CLOSE_BRACE_TOKEN
annot_body_nested ::= OPEN_NESTED_BRACE_TOKEN TokensIgnore CLOSE_NESTED_BRACE_TOKEN

annot_attach_points ::= annot_attach_point (COMMA_TOKEN annot_attach_point)*
annot_attach_point ::=
   dual_attach_point
   | source_only_attach_point
dual_attach_point ::= [SOURCE_KEYWORD] dual_attach_point_ident
dual_attach_point_ident ::=
   TYPE_KEYWORD
   | CLASS_KEYWORD
   | PARAMETER_KEYWORD
   | RETURN_KEYWORD
   | [OBJECT_KEYWORD|SERVICE_KEYWORD|REMOTE_KEYWORD] FUNCTION_KEYWORD
   | [OBJECT_KEYWORD|SERVICE_KEYWORD|REMOTE_KEYWORD] REMOTE_KEYWORD FUNCTION_KEYWORD
   | SERVICE_KEYWORD
   | [OBJECT_KEYWORD|RECORD_KEYWORD] FIELD_KEYWORD
source_only_attach_point ::= SOURCE_KEYWORD source_only_attach_point_ident
source_only_attach_point_ident ::=
   ANNOTATION_KEYWORD
   | EXTERNAL_KEYWORD
   | VAR_KEYWORD
   | CONST_KEYWORD
   | LISTENER_KEYWORD
   | CLIENT_KEYWORD
   | WORKER_KEYWORD

private identifier ::= IDENTIFIER_TOKEN | KEY_KEYWORD {pin=1}

string_literal ::= STRING_LITERAL_TOKEN

int_literal ::= DECIMAL_INTEGER_LITERAL_TOKEN | HEX_INTEGER_LITERAL_TOKEN

floating_point_literal ::= DECIMAL_FLOATING_POINT_LITERAL_TOKEN | HEX_FLOATING_POINT_LITERAL_TOKEN


documentationString ::= documentationLine+ parameterDocumentationLine* returnParameterDocumentationLine? deprecatedParametersDocumentationLine? deprecatedAnnotationDocumentationLine?
documentationLine ::= MARKDOWN_DOCUMENTATION_LINE_START documentationContent {pin=1}
parameterDocumentationLine ::= parameterDocumentation parameterDescription*
returnParameterDocumentationLine ::= returnParameterDocumentation returnParameterDescription*
deprecatedAnnotationDocumentationLine ::= deprecatedAnnotationDocumentation deprecateAnnotationDescriptionLine*
deprecatedParametersDocumentationLine ::= deprecatedParametersDocumentation parameterDocumentationLine+
documentationContent ::= documentationText?
parameterDescription ::= MARKDOWN_DOCUMENTATION_LINE_START documentationText?
returnParameterDescription ::= MARKDOWN_DOCUMENTATION_LINE_START documentationText?
deprecateAnnotationDescriptionLine ::= MARKDOWN_DOCUMENTATION_LINE_START documentationText?

documentationText ::= (documentationReference | referenceType | backtickedBlock | documentationTextContent)+
documentationReference ::= referenceType SINGLE_BACKTICK_CONTENT SINGLE_BACKTICK_MARKDOWN_END {pin=1}
referenceType ::= DOCTYPE | DOCSERVICE | DOCVARIABLE | DOCVAR | DOCANNOTATION | DOCMODULE | DOCFUNCTION | DOCPARAMETER | DOCCONST

parameterDocumentation ::= PARAMETER_DOCUMENTATION_START PARAMETER_NAME DESCRIPTION_SEPARATOR documentationText? {pin=3}
returnParameterDocumentation ::= RETURN_PARAMETER_DOCUMENTATION_START docParameterDescription
deprecatedAnnotationDocumentation ::= DEPRECATED_DOCUMENTATION
deprecatedParametersDocumentation ::= DEPRECATED_PARAMETER_DOCUMENTATION
docParameterDescription ::= documentationText?

backtickedBlock ::=  singleBacktickedBlock
singleBacktickedBlock ::= SINGLE_BACKTICK_MARKDOWN_START SINGLE_BACKTICK_CONTENT? SINGLE_BACKTICK_MARKDOWN_END {pin=1}

documentationTextContent ::= MARKDOWN_DOCUMENTATION_TEXT | DOCUMENTATION_ESCAPED_CHARACTERS





private allTokens ::= keyword | type | separatorIn | operator | literal | docRef | contextual
| REMULTIFLAG | REDOTALLFLAG | REIGNORECASEFLAG | RECOMMENTFLAG | REESCAPE | RECHARSETLITERALCHAR | RELITERALCHAR
| DOCTYPE | DOCSERVICE | DOCVARIABLE | DOCVAR | DOCANNOTATION | DOCMODULE | DOCFUNCTION | DOCPARAMETER | DOCCONST | MARKDOWN_DOCUMENTATION_LINE_START | PARAMETER_DOCUMENTATION_START | RETURN_PARAMETER_DOCUMENTATION_START | MARKDOWN_DOCUMENTATION_TEXT | PARAMETER_NAME | DESCRIPTION_SEPARATOR
| DEPRECATED_DOCUMENTATION | DEPRECATED_PARAMETER_DOCUMENTATION | SINGLE_BACKTICK_MARKDOWN_START | SINGLE_BACKTICK_MARKDOWN_END | DOUBLE_BACKTICK_MARKDOWN_START | DOUBLE_BACKTICK_MARKDOWN_END | TRIPLE_BACKTICK_MARKDOWN_START | TRIPLE_BACKTICK_MARKDOWN_END | DOCUMENTATION_ESCAPED_CHARACTERS | SINGLE_BACKTICK_CONTENT | DOUBLE_BACKTICK_CONTENT | TRIPLE_BACKTICK_CONTENT

private allTokensIgnore ::= keyword | type | separatorIgnore | operator | literal | docRef | contextual
| REMULTIFLAG | REDOTALLFLAG | REIGNORECASEFLAG | RECOMMENTFLAG | REESCAPE | RECHARSETLITERALCHAR | RELITERALCHAR
| DOCTYPE | DOCSERVICE | DOCVARIABLE | DOCVAR | DOCANNOTATION | DOCMODULE | DOCFUNCTION | DOCPARAMETER | DOCCONST | MARKDOWN_DOCUMENTATION_LINE_START | PARAMETER_DOCUMENTATION_START | RETURN_PARAMETER_DOCUMENTATION_START | MARKDOWN_DOCUMENTATION_TEXT | PARAMETER_NAME | DESCRIPTION_SEPARATOR
| DEPRECATED_DOCUMENTATION | DEPRECATED_PARAMETER_DOCUMENTATION | SINGLE_BACKTICK_MARKDOWN_START | SINGLE_BACKTICK_MARKDOWN_END | DOUBLE_BACKTICK_MARKDOWN_START | DOUBLE_BACKTICK_MARKDOWN_END | TRIPLE_BACKTICK_MARKDOWN_START | TRIPLE_BACKTICK_MARKDOWN_END | DOCUMENTATION_ESCAPED_CHARACTERS | SINGLE_BACKTICK_CONTENT | DOUBLE_BACKTICK_CONTENT | TRIPLE_BACKTICK_CONTENT


private allTokensPipe ::= keyword | type | separatorPipe | operator | literal | docRef | contextual
| REMULTIFLAG | REDOTALLFLAG | REIGNORECASEFLAG | RECOMMENTFLAG | REESCAPE | RECHARSETLITERALCHAR | RELITERALCHAR
| DOCTYPE | DOCSERVICE | DOCVARIABLE | DOCVAR | DOCANNOTATION | DOCMODULE | DOCFUNCTION | DOCPARAMETER | DOCCONST | MARKDOWN_DOCUMENTATION_LINE_START | PARAMETER_DOCUMENTATION_START | RETURN_PARAMETER_DOCUMENTATION_START | MARKDOWN_DOCUMENTATION_TEXT | PARAMETER_NAME | DESCRIPTION_SEPARATOR
| DEPRECATED_DOCUMENTATION | DEPRECATED_PARAMETER_DOCUMENTATION | SINGLE_BACKTICK_MARKDOWN_START | SINGLE_BACKTICK_MARKDOWN_END | DOUBLE_BACKTICK_MARKDOWN_START | DOUBLE_BACKTICK_MARKDOWN_END | TRIPLE_BACKTICK_MARKDOWN_START | TRIPLE_BACKTICK_MARKDOWN_END | DOCUMENTATION_ESCAPED_CHARACTERS | SINGLE_BACKTICK_CONTENT | DOUBLE_BACKTICK_CONTENT | TRIPLE_BACKTICK_CONTENT


// Keywords

private keyword ::= (PUBLIC_KEYWORD
    |PRIVATE_KEYWORD
    |REMOTE_KEYWORD
    |ABSTRACT_KEYWORD
    |CLIENT_KEYWORD
    |IMPORT_KEYWORD
    |FUNCTION_KEYWORD
    |CONST_KEYWORD
    |LISTENER_KEYWORD
    |SERVICE_KEYWORD
    |XMLNS_KEYWORD
    |ANNOTATION_KEYWORD
    |TYPE_KEYWORD
    |RECORD_KEYWORD
    |OBJECT_KEYWORD
    |AS_KEYWORD
    |ON_KEYWORD
    |RESOURCE_KEYWORD
    |FINAL_KEYWORD
    |SOURCE_KEYWORD
    |WORKER_KEYWORD
    |PARAMETER_KEYWORD
    |FIELD_KEYWORD
    |ISOLATED_KEYWORD
    |RETURNS_KEYWORD
    |RETURN_KEYWORD
    |EXTERNAL_KEYWORD
    |TRUE_KEYWORD
    |FALSE_KEYWORD
    |IF_KEYWORD
    |ELSE_KEYWORD
    |ELSEIF_KEYWORD
    |WHILE_KEYWORD
    |CHECK_KEYWORD
    |CHECKPANIC_KEYWORD
    |PANIC_KEYWORD
    |CONTINUE_KEYWORD
    |BREAK_KEYWORD
    |TYPEOF_KEYWORD
    |IS_KEYWORD
    |NULL_KEYWORD
    |LOCK_KEYWORD
    |FORK_KEYWORD
    |TRAP_KEYWORD
    |IN_KEYWORD
    |FOREACH_KEYWORD
    |TABLE_KEYWORD
    |KEY_KEYWORD
    |LET_KEYWORD
    |NEW_KEYWORD
    |FROM_KEYWORD
    |WHERE_KEYWORD
    |SELECT_KEYWORD
    |START_KEYWORD
    |FLUSH_KEYWORD
    |CONFIGURABLE_KEYWORD
    |WAIT_KEYWORD
    |DO_KEYWORD
    |TRANSACTION_KEYWORD
    |TRANSACTIONAL_KEYWORD
    |COMMIT_KEYWORD
    |ROLLBACK_KEYWORD
    |RETRY_KEYWORD
    |ENUM_KEYWORD
    |BASE16_KEYWORD
    |BASE64_KEYWORD
    |MATCH_KEYWORD
    |CONFLICT_KEYWORD
    |LIMIT_KEYWORD
    |JOIN_KEYWORD
    |OUTER_KEYWORD
    |EQUALS_KEYWORD
    |CLASS_KEYWORD
    |ORDER_KEYWORD
    |BY_KEYWORD
    |ASCENDING_KEYWORD
    |DESCENDING_KEYWORD
    |UNDERSCORE_KEYWORD
    |NOT_IS_KEYWORD)

    // Type keywords
private type::= (INT_KEYWORD
    |BYTE_KEYWORD
    |FLOAT_KEYWORD
    |DECIMAL_KEYWORD
    |STRING_KEYWORD
    |BOOLEAN_KEYWORD
    |XML_KEYWORD
    |JSON_KEYWORD
    |HANDLE_KEYWORD
    |ANY_KEYWORD
    |ANYDATA_KEYWORD
    |NEVER_KEYWORD
    |VAR_KEYWORD
    |MAP_KEYWORD
    |FUTURE_KEYWORD
    |TYPEDESC_KEYWORD
    |ERROR_KEYWORD
    |STREAM_KEYWORD
    |READONLY_KEYWORD
    |DISTINCT_KEYWORD
    |FAIL_KEYWORD)


    // Contextual keywords

private contextual ::= (RE_KEYWORD
    |GROUP_KEYWORD
    |COLLECT_KEYWORD)


private separatorIn ::=  (OPEN_NESTED_BRACE_TOKEN|IGNORED_OPEN_BRACE_TOKEN
    |CLOSE_NESTED_BRACE_TOKEN|IGNORED_CLOSE_BRACE_TOKEN
    |OPEN_PAREN_TOKEN
    |CLOSE_PAREN_TOKEN
    |OPEN_BRACKET_TOKEN
    |CLOSE_BRACKET_TOKEN
    |SEMICOLON_TOKEN|IGNORED_SEMICOLON_TOKEN
    |DOT_TOKEN
    |COLON_TOKEN
    |COMMA_TOKEN
    |ELLIPSIS_TOKEN
    |OPEN_BRACE_PIPE_TOKEN|OPEN_NESTED_BRACE_PIPE_TOKEN|IGNORED_OPEN_BRACE_PIPE_TOKEN
    |CLOSE_BRACE_PIPE_TOKEN|CLOSE_NESTED_BRACE_PIPE_TOKEN|IGNORED_CLOSE_BRACE_PIPE_TOKEN
    |AT_TOKEN
    |HASH_TOKEN
    |BACKTICK_TOKEN
    |DOUBLE_QUOTE_TOKEN
    |SINGLE_QUOTE_TOKEN
    |STRING_TEMPLATE_START_TOKEN
    |STRING_TEMPLATE_END_TOKEN
    |DOUBLE_BACKTICK_TOKEN
    |TRIPLE_BACKTICK_TOKEN)

private separatorIgnore ::=  (IGNORED_OPEN_BRACE_TOKEN
    |IGNORED_CLOSE_BRACE_TOKEN
    |OPEN_PAREN_TOKEN
    |CLOSE_PAREN_TOKEN
    |OPEN_BRACKET_TOKEN
    |CLOSE_BRACKET_TOKEN
    |SEMICOLON_TOKEN|IGNORED_SEMICOLON_TOKEN
    |DOT_TOKEN
    |COLON_TOKEN
    |COMMA_TOKEN
    |ELLIPSIS_TOKEN
    |OPEN_BRACE_PIPE_TOKEN|OPEN_NESTED_BRACE_PIPE_TOKEN|IGNORED_OPEN_BRACE_PIPE_TOKEN
    |CLOSE_BRACE_PIPE_TOKEN|CLOSE_NESTED_BRACE_PIPE_TOKEN|IGNORED_CLOSE_BRACE_PIPE_TOKEN
    |AT_TOKEN
    |HASH_TOKEN
    |BACKTICK_TOKEN
    |DOUBLE_QUOTE_TOKEN
    |SINGLE_QUOTE_TOKEN
    |STRING_TEMPLATE_START_TOKEN
    |STRING_TEMPLATE_END_TOKEN
    |DOUBLE_BACKTICK_TOKEN
    |TRIPLE_BACKTICK_TOKEN)

private separatorPipe ::=  (OPEN_BRACE_TOKEN|OPEN_NESTED_BRACE_TOKEN|IGNORED_OPEN_BRACE_TOKEN
           |CLOSE_BRACE_TOKEN|CLOSE_NESTED_BRACE_TOKEN|IGNORED_CLOSE_BRACE_TOKEN
           |OPEN_PAREN_TOKEN
           |CLOSE_PAREN_TOKEN
           |OPEN_BRACKET_TOKEN
           |CLOSE_BRACKET_TOKEN
           |SEMICOLON_TOKEN|IGNORED_SEMICOLON_TOKEN
           |DOT_TOKEN
           |COLON_TOKEN
           |COMMA_TOKEN
           |ELLIPSIS_TOKEN
           |OPEN_NESTED_BRACE_PIPE_TOKEN|IGNORED_OPEN_BRACE_PIPE_TOKEN
           |CLOSE_NESTED_BRACE_PIPE_TOKEN|IGNORED_CLOSE_BRACE_PIPE_TOKEN
           |AT_TOKEN
           |HASH_TOKEN
           |BACKTICK_TOKEN
           |DOUBLE_QUOTE_TOKEN
           |SINGLE_QUOTE_TOKEN
           |STRING_TEMPLATE_START_TOKEN
           |STRING_TEMPLATE_END_TOKEN
           |DOUBLE_BACKTICK_TOKEN
           |TRIPLE_BACKTICK_TOKEN)


    // Operators
private operator ::=  (EQUAL_TOKEN
    |DOUBLE_EQUAL_TOKEN
    |TRIPPLE_EQUAL_TOKEN
    |PLUS_TOKEN
    |MINUS_TOKEN
    |SLASH_TOKEN
    |PERCENT_TOKEN
    |ASTERISK_TOKEN
    |LT_TOKEN
    |LT_EQUAL_TOKEN
    |GT_TOKEN
    |RIGHT_DOUBLE_ARROW_TOKEN
    |QUESTION_MARK_TOKEN
    |PIPE_TOKEN
    |GT_EQUAL_TOKEN
    |EXCLAMATION_MARK_TOKEN
    |NOT_EQUAL_TOKEN
    |NOT_DOUBLE_EQUAL_TOKEN
    |BITWISE_AND_TOKEN
    |BITWISE_XOR_TOKEN
    |LOGICAL_AND_TOKEN
    |LOGICAL_OR_TOKEN
    |NEGATION_TOKEN
    |RIGHT_ARROW_TOKEN
    |INTERPOLATION_START_TOKEN
    |INTERPOLATION_END_TOKEN
    |XML_PI_START_TOKEN
    |XML_PI_END_TOKEN
    |XML_COMMENT_START_TOKEN
    |XML_COMMENT_END_TOKEN
    |SYNC_SEND_TOKEN
    |LEFT_ARROW_TOKEN
    |DOUBLE_DOT_LT_TOKEN
    |DOUBLE_LT_TOKEN
    |ANNOT_CHAINING_TOKEN
    |OPTIONAL_CHAINING_TOKEN
    |ELVIS_TOKEN
    |DOT_LT_TOKEN
    |SLASH_LT_TOKEN
    |DOUBLE_SLASH_DOUBLE_ASTERISK_LT_TOKEN
    |SLASH_ASTERISK_TOKEN
    |DOUBLE_GT_TOKEN
    |TRIPPLE_GT_TOKEN
    |XML_CDATA_START_TOKEN
    |XML_CDATA_END_TOKEN
    |BACK_SLASH_TOKEN
    |DOLLAR_TOKEN
    |ESCAPED_MINUS_TOKEN)


    // Documentation reference types
private docRef ::=    (TYPE_DOC_REFERENCE_TOKEN
    |SERVICE_DOC_REFERENCE_TOKEN
    |VARIABLE_DOC_REFERENCE_TOKEN
    |VAR_DOC_REFERENCE_TOKEN
    |ANNOTATION_DOC_REFERENCE_TOKEN
    |MODULE_DOC_REFERENCE_TOKEN
    |FUNCTION_DOC_REFERENCE_TOKEN
    |PARAMETER_DOC_REFERENCE_TOKEN
    |CONST_DOC_REFERENCE_TOKEN)


    // Literal tokens
private literal ::=    (IDENTIFIER_TOKEN
    |STRING_LITERAL_TOKEN
    |DECIMAL_INTEGER_LITERAL_TOKEN
    |HEX_INTEGER_LITERAL_TOKEN
    |DECIMAL_FLOATING_POINT_LITERAL_TOKEN
    |HEX_FLOATING_POINT_LITERAL_TOKEN
    |XML_TEXT_CONTENT
    |TEMPLATE_STRING)

    // Other
invalid ::= INVALID_TOKEN

    //_---------------------------------------------non-terminal-kinds-----------------------------------------------

    // Minutiae kinds
minutiae ::=    (WHITESPACE_MINUTIAE
    |END_OF_LINE_MINUTIAE
    |COMMENT_MINUTIAE
    |INVALID_NODE_MINUTIAE)

other ::= EOF_TOKEN
